## x만큼 간격이 있는 n개 숫자

> 함수 solution은 정수 `x`와 자연수 `n`을 입력 받아, `x`부터 시작해 `x`씩 증가하는 숫자를 `n`개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.

<br>

**1. 풀이**

- 무난히 `for` 반복문과 값을 배열에 넣기 위한 `push()` 메소드를 사용해 풀이했다.

<br>

**2.알게 된 내용**
![정답입니다](../images/programmars_16.png)

- 그런데 엥? 왜 7점이나 주는거지?.. 특이하네.. 그냥 정석 방식 아닌가 😅

```javascript
function solution(x, n) {
  return Array(n)
    .fill(x)
    .map((v, i) => (i + 1) * v);
}
```

- `Array().fill()`을 활용한 풀이법이다. `Array(n)`을 사용해 길이가 `n`인 배열을 먼저 생성하고, `.fill(x)` 메소드를 이용해 배열의 모든 원소를 `x`로 채운다.
- 그 다음 `.map()` 메소드를 사용해 배열의 각 원소에 대해 `(i + 1) * v`를 계산하여 새로운 배열을 생성하고 반환한다. `map()` 메소드를 사용하여 배열을 한 번에 변형하는 방식.
  <br>
- 물론 이 코드가 보기에는 더 깔끔해보이긴 하지만 기존에 `for`문을 활용해 작성한 방식이 **가독성** 이나 **성능** 측면에서 더 낫다고 한다.
- `for`문을 활용해 `push()` 하는 방식은 배열의 크기가 커질 때마다 `push()`가 배열의 끝에 요소를 추가하는 데 시간이 소요될 수 있으나 메모리를 한 번에 할당하는 것이 아니라 점진적으로 증가시키므로, 메모리 할당 측면에서 좀 더 유연하게 동작할 수 있다.
- 다만 `Array().fill()` 방식은 먼저 배열을 채우고 나서 `map()`을 활용해 각 요소를 변형해 새로운 배열을 반환하는 방식이기 때문에 기존 배열을 수정하는 것보다 메모리를 좀 더 많이 사용하게 된다. 이 방식은 배열의 크기가 커질수록 `fill()`과 `map()`의 두 번의 연산이 필요하므로 성능 측면에서 `for`문의 코드에 비해 다소 느릴 수 있다.

> 간결함과 가독성, 성능을 비교하자면 나는 후자에 집중하고 싶은 타입이므로 예시 코드는 작동 방식을 이해하는 정도에서 그치는 것이 좋겠다!
